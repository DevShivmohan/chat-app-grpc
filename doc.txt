Java Spring Boot Grpc - an exhaustive example

 * stream - if connection closed, does onError() called ??

 * if onNext() called fast after onCompleted() - can onCompleted() be called before big onNext() finished to process?

 lifecycle of the stream


 concurrent calls to onNext():
                            - happens-before ?
                            - shared resources ?
                            - same OR different threads ?
                            - context ?


 == SSL ==

 - server -
 Server secureServer = ServerBuilder.forPort(50051)
                                    .addService(new GreetServiceImpl())
                                    .useTransportSecurity(
                                        new File("ssl/server.crt"),
                                        new File("ssl/server.pem")
                                    ).build();
 - client -
 ManagedChannel secureChannel = NettyChannelBuilder.forAddress("localhost", 50051)
                                                   .sslContext(GrpcSslContexts.forClient()
                                                                              .trustManager(new File("root.pem"))
                                                                              .build())



HTTP1.1 opens new TCP connection to server at each request, does not compress header, only works on req/res pattern, no server push is allowed.
Headers in plain text, each req/res exchange involves many overhead in transmission.

HTTP2 allows client and server push messages in parallel in same TCP connection, reduces latency. Support server push and header compression , it’s via binary protocol, faster and efficient , It’s also secure.



